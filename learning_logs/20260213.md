# DB를 생성하시오.
1. DB를 생성 하시오
  - DB 명 : play_transaction
2. TABLE을 생성하시오.
  - table명 : products
    - column명 : 
      1. products_name varchar(50) / pk
      2. stock int / not null

  - table 명 : orders
    - column 명 :
      1. order_id / int / auto_increment / pk
      2. product_name varchar(50) / fk / 
      3. quantity int

```sql
CREATE TABLE products (
	products_name VARCHAR(50) PRIMARY KEY,
	stock INT NOT NULL);
	
CREATE TABLE orders (
	order_id INT AUTO_INCREMENT PRIMARY KEY,
	product_name VARCHAR(50),
	quantity INT);
```

# Transaction
## 정의
- 트랜잭션은 데이터베이스의 같애를 변화시키기 위해서 수행하는 _논리적인 작업단위_ 를 의미. 여러개의 SQL문을 묶어서 모두 성공하거나, 아예 수행되지않은 상태로 처리하는것을 의미.

- python 상에서 coffeemMachine을 할때를 생각해보면 특정 함수/메서드가 성공했을때만 다음단계로 넘어갔엇고, 아니면 아예 실패하면서 profit의 변화나 resources에서 변화가 없었음.

- 즉 현재까지를 기준으로 SQL문을 다수 작성해놓고 그것을 하나의 루틴으로 묶은 SQL문 수준의 함수/메서드와 유사.

## 트랜잭션의 특성
1. `원자성` (Atomicity) : 트랜잭션 내 작업은 모두 반영되거나 모두 취소되어야함.
2. `일관성` (Consistency) : 트랜잭션 완료 후 DB는 항상 미리 정의된 제약 조건을 준수해야함.
3. `격리성` (Isolation) : 실행중인 트랜잭션은 다른 트랜잭션의 간섭을 받지 않아야 함.
4. `지속성/영속성` (Durability) : 트랜잭션 결과는 시스템 오류가 발생해도 영구적으로 저장 됨.

## 트랜잭션 제어어(TCL : Transaction Control Language)
1. `START TRANSACTION` : 트랜잭션 시작

2. `COMMIT` : 모든 작업이 정상일때, 변경 내용을 실제 DB에 영구 저장.

3. `ROLLBACK` : 작업 오류 발생시 , `START TRANSACTION` 직전 상태로 돌아감.


## 예시: 주문 + 재고 차감(성공/실패)
```sql
성공 예시
START TRANSACTION;

-- 주문 접수
INSERT INTO orders (product_name, quantity)
VALUES ('iPhone18ProMax', 2);

-- 재고 차감 (재고가 충분할 때만 차감되도록 조건을 걸면 더 안전함)
UPDATE products
SET stock = stock - 2
WHERE products_name = 'iPhone18ProMax'
  AND stock >= 2;

COMMIT;

SELECT * FROM products;
SELECT * FROM orders;
```
## 실패 예시(에러 발생 → 롤백)
```sql
START TRANSACTION;

-- 존재하지 않는 테이블에 INSERT 시도(에러)
INSERT INTO orders_miss (product_name, quantity)
VALUES ('GalaxyS26Ultra', 1);

-- 아래 UPDATE는 실행되기 전에 위에서 에러로 멈추거나,
-- 상황에 따라 전체를 롤백해야 함
UPDATE products
SET stock = stock - 1
WHERE products_name = 'GalaxyS26Ultra';

ROLLBACK;

SELECT * FROM products;
SELECT * FROM orders;
```
## “재고가 음수면 어떡하지?”에 대한 올바른 처리

- SELECT stock < 0 같은 조회는 확인용이고, 그것만으로 자동 롤백이 되진 않는다.

- 음수 재고를 방지하려면 재고 차감 자체를 조건부로 만들어 트랜잭션 안에서 실패 처리(ROLLBACK)되게 설계해야 한다.

### 예: 재고가 충분할 때만 차감되도록 조건을 넣기
```sql
START TRANSACTION;

UPDATE products
SET stock = stock - 1
WHERE products_name = 'GalaxyS26Ultra'
  AND stock >= 1;

-- UPDATE가 0행이면(재고 부족) 주문을 넣지 말고 ROLLBACK 처리

COMMIT;
```


# Trigger
## 정의
테이블에 insert, update, delete와 같은 이벤트가 발생했을때 데이터베이스가 자동으로 실행하도록 설정된 SQL 블록.

- 활용사례
  - 주문 재고시 자동 차감(데이터 연동)
  - 데이터 변경 시 로그기록(검사 및 기록)
  - 특정 조건 미달시 데이터 입력 차단(무결성 강화)

## 트랜잭션과의 차이점
- 둘다 데이터의 무결성을 지키기 위한 것이라는 공통점을 가지지만, 작동하는 방식과 주체에서의 차이가 존재함.

### Transaction
- 핵심 성격 : 논리적 작업 단위(묶음 처리)
- 실행 주체 : 개발자 (본인이 직접 작성)
- 작동 시점 : `START` / `COMMIT` 시점
- 주요 목적 : 데이터의 안전한 _일괄처리_

즉 내가 SELCET 눌러보고 하나하나 체크해서 이게 명확한 테이블 명이고 컬럼명인지 확신을 못하고 있는 상황에서 중간 과정에 값이 바뀌면 안되니까 보험 걸어놓고 묶어둔 SQL문을 실행시킬려면 : TRANSACTION 적용

### Trigger
- 핵심 성격 : 이벤트 반응
- 실행 주체 : DBMS가 자동으로 실행
- 작동 시점 : `INSERT/UPDATE/DELETE` 발생 시
- 주요 목적 : 데이터 간의 _자동 연동 및 기록_

DB에 미리 정의 해놓고 _누군가가 orders에 데이터를 집어넣었네(외부에서 나에게 주문을 넣었다면)? -> DB가 감시하고 있다가 products 테이블에 재고 빼는거 샐행 -> 근데 음수값? -> '재고가 부족합니다'를 실행._ 와 같은 부분을 정의된 대로 실행시킴.

## 정리
**트리거는 트랜잭션의 일부** 에 해당함. insert를 할때 트리거가 발동 되거 재고를 깎는데 오류가 나면 INSERT를 포함한 전체 트랜잭션이 실패함. 즉, 트리거도 트랜잭션의 `원자성`을 따른다고 해석가능.

* 여기서 더 발전하면 Stored Procedure 개념도 있지만 JPA에서도 안다루고 SQLD에 없다면 이런게 있다는 정도만 알고있으면 됨.